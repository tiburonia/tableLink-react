오케이, 완전 처음부터 다시 갈 거면 Replit AI에 이대로 복붙해. 최대한 명확하고 모듈화해서 요청문 써줬어.

---

# 🚀 Replit AI 요청 프롬프트 (복붙해서 써)

**목표**
카카오맵 JS API 기반 “동적 마커 시스템”을 처음부터 구현해줘.
줌 레벨에 따라 **개별 매장 마커**와 **지역 집계 마커**가 절대 동시에 보이지 않도록 해.

**레벨 정책**

* 레벨 **1–5**: 개별 매장 마커만 표시
* 레벨 **6–7**: **읍/면/동** 집계 마커만 표시
* 레벨 **8–9**: **시/군/구** 집계 마커만 표시
* 레벨 **10+**: **시/도** 집계 마커만 표시

---

## 구현 조건 (핵심 아키텍처)

1. **레이어 분리**

* `storeMarkers`(개별 매장) vs `regionOverlays`(집계 마커/오버레이) 완전 분리
* 전환 시 항상 반대 레이어는 **hide** 처리

2. **단일 전환 스위치**

* `handleMapLevelChange(map, stores)` **한 곳에서만** 모드 전환
* 내부 분기:

  * `getModeByLevel(level): 'store' | 'region'`
  * `getRegionTierByLevel(level): 'dong' | 'sigungu' | 'sido'`

3. **캐싱 & 재사용**

* 개별 마커는 **최초 1회 생성** 후 show/hide만
* 지역 집계는 tier별 그룹 결과를 메모리 캐시(`regionCache`)로 재사용

4. **주소 파싱(한국형)**

* 입력 예: `서울특별시 강남구 테헤란로 123 (역삼동, ○○빌딩)`
* 파싱 규칙:

  * 시/도 우선 추출
  * 시/군/구는 시/도 뒤 구간에서 추출
  * 동은 **괄호 속 ○○동을 우선**, 없으면 본문에서 `(읍|면|동)` 패턴 추출
  * 실패 시 `'미상'`으로 처리(옵션으로 제외 가능)

---

## 요구 함수 시그니처(고정)

* `getModeByLevel(level): 'store' | 'region'`
* `getRegionTierByLevel(level): 'dong' | 'sigungu' | 'sido'`
* `parseKoreanAddress(addr): {sido, sigungu, dong}`
* `groupStoresByTier(stores, tier): Group[]` // 센트로이드(lat/lng 평균) 포함
* `buildStoreMarkers(stores, map): Promise<void>` // 최초 1회만 생성, 기본은 숨김
* `showStoreMarkers(map): void` / `hideStoreMarkers(): void`
* `buildRegionOverlaysFromGroups(groups, map): void`
* `showRegionOverlays(map): void` / `hideRegionOverlays(): void`
* `clearRegionOverlays(): void`
* `handleMapLevelChange(map, stores): void`  ← **유일한 전환 스위치**
* `initMapWithMarkers(map, stores): Promise<void>` // 초기화 진입점

**타입 가정**

```ts
type Store = { id: string|number; name: string; address: string; lat: number; lng: number; };
type Group = { key: string; lat: number; lng: number; count: number; items: Store[]; };
```

---

## UI/이벤트

* 집계 마커는 `kakao.maps.CustomOverlay`로 작은 배지(이름/개수) 형태
* 배지 클릭 시: 지도 한 단계 확대하거나, 그룹 리스트 패널 오픈 훅만 연결
* 지도 이벤트: `zoom_changed`(필수), 필요하면 `idle` 추가
* 연속 이벤트에 대비해 `debounce(100~150ms)` 적용

---

## 초기화 플로우

1. `initMapWithMarkers(map, stores)`에서 `buildStoreMarkers`로 **생성만** 해두고 숨김
2. `handleMapLevelChange(map, stores)` 한 번 호출해 초기 상태 반영
3. `zoom_changed`에서 **오직** `handleMapLevelChange`만 호출

---

## 데이터 입력

* `stores`는 `{ id, name, address, lat, lng }[]` 형태
* 주소 파싱 실패(‘미상’) 항목은 그룹에서 **한 묶음**으로 모으거나 옵션으로 제외 가능하게 설계

---

## 수용 기준(테스트 체크리스트)

1. 레벨 1–5: 집계 0, 개별만 표시
2. 레벨 6–7: 개별 0, **읍/면/동** 집계만
3. 레벨 8–9: 개별 0, **시/군/구** 집계만
4. 레벨 10+: 개별 0, **시/도** 집계만
5. 줌 인/아웃 반복 시 불필요한 재생성 없음(개별은 최초 1회, 집계는 캐시 재사용)
6. 괄호 안 동을 우선 반영해 동단위 집계 정확
7. ‘미상’ 처리 정책이 옵션대로 동작(포함/제외)

---

## 산출물

* 위 함수 시그니처를 갖춘 **모듈형 JS 코드**
* README 섹션(짧게): 설치/초기화 방법, 레벨 정책, 옵션 설명
* 간단 데모 HTML(맵 1개 + 더미 stores 10\~20개) 포함해서 동작 검증 가능하게

---

> 기존 코드가 있다면, 동일 시그니처로 **교체/래핑**해서 바로 들어갈 수 있게 구현해줘.
> 특히 **전환 로직은 `handleMapLevelChange` 단일 진입**만 쓰도록 보장해줘.
