리팩토링 목표

API 하나로 개별 마커/집계 마커를 모두 제공

입력: 지도 레벨(level) + 뷰포트(bbox: xmin,ymin,xmax,ymax)

출력: 해당 뷰포트 안의 클러스터 결과(집계 마커) 또는 개별 매장 마커

클러스터링/중복제거/집계는 전부 DB(PostGIS) 에서 처리

프론트는 받은 GeoJSON-like 결과를 그대로 렌더

0) 전제 (스키마/좌표계/인덱스)

테이블: store_addresses(id, store_id, road_address, geom GEOMETRY(Point, 4326), ... )

SRID: 4326(WGS84)

인덱스(반드시):

CREATE INDEX IF NOT EXISTS idx_store_addresses_geom
  ON store_addresses USING GIST (geom);

1) 레벨→클러스터 셀 크기 매핑(정책)

네 레벨 규칙(숫자 작을수록 확대, 클수록 축소)을 유지하면서 그리드 크기를 정해.

if level <= 5   -> individual (개별 마커, 클러스터링 X)
if 6 <= level <= 7  -> gridSizeMeters = 300
if 8 <= level <= 10 -> gridSizeMeters = 2000
if level > 10       -> gridSizeMeters = 10000


이유: 클러스터는 미터 기반이 편하므로 쿼리에서는 4326 → 3857(WebMercator) 로 변환 후 Snapping.

2) 단일 통합 엔드포인트 설계
GET /api/stores/clusters?level=7&bbox=xmin,ymin,xmax,ymax


level: 정수(네 지도 레벨)

bbox: 경도/위도 순서로 4326 기준 "xmin,ymin,xmax,ymax"

응답: 아래 두 가지 중 하나

individual: 매장 단위 목록

cluster: 집계 마커 목록(각 클러스터의 대표 위치 + 개수)

3) SQL — 뷰포트 필터 공통 부분
-- bbox 파라미터로 들어온 경계
-- $1=$xmin, $2=$ymin, $3=$xmax, $4=$ymax, SRID=4326
WITH viewport AS (
  SELECT ST_MakeEnvelope($1, $2, $3, $4, 4326) AS box
)

4) SQL — 개별 마커(zoom in; level <= 5)
WITH viewport AS (
  SELECT ST_MakeEnvelope($1, $2, $3, $4, 4326) AS box
)
SELECT
  'individual' AS kind,
  sa.id,
  sa.store_id,
  sa.road_address,
  ST_X(sa.geom) AS lon,
  ST_Y(sa.geom) AS lat
FROM store_addresses sa, viewport v
WHERE sa.geom && v.box          -- 인덱스 타는 1차 필터
  AND ST_Intersects(sa.geom, v.box)
LIMIT 5000;                      -- 안전 장치 (필요시 조정)


NOTE: LIMIT는 과도한 오브젝트 폭주 방지용. 필요 시 타일링/페이징과 함께 조정.

5) SQL — 클러스터 마커(zoom out; level >= 6)

핵심은 3857로 변환 → ST_SnapToGrid 로 셀 키 생성 → 그룹화.

-- $1=$xmin, $2=$ymin, $3=$xmax, $4=$ymax, $5=gridSizeMeters
WITH
viewport AS (
  SELECT ST_MakeEnvelope($1, $2, $3, $4, 4326) AS box4326
),
v3857 AS (
  SELECT ST_Transform(box4326, 3857) AS box3857 FROM viewport
),
filtered AS (
  -- 먼저 뷰포트 교차로 줄이기 (4326)
  SELECT sa.*
  FROM store_addresses sa, viewport v
  WHERE sa.geom && v.box4326
    AND ST_Intersects(sa.geom, v.box4326)
),
projected AS (
  SELECT
    id, store_id, road_address,
    ST_Transform(geom, 3857) AS g3857
  FROM filtered
),
gridded AS (
  SELECT
    ST_SnapToGrid(g3857, $5, $5) AS cell,  -- $5 = gridSizeMeters
    COUNT(*) AS count,
    -- 대표점(3857에서 계산 후 4326으로 복원)
    ST_Transform(
      ST_PointOnSurface(ST_Collect(g3857)),
      4326
    ) AS rep_geom
  FROM projected, v3857
  WHERE g3857 && v3857.box3857
  GROUP BY ST_SnapToGrid(g3857, $5, $5)
)
SELECT
  'cluster' AS kind,
  count,
  ST_X(rep_geom) AS lon,
  ST_Y(rep_geom) AS lat
FROM gridded;


포인트 선택:

ST_PointOnSurface(ST_Collect(...))는 폴리곤에도 안전. 포인트 집합에도 잘 동작.

단순 ST_Centroid를 써도 됨. (겹침/가시성은 PointOnSurface가 안정적일 때가 많음)

6) Express.js 라우터 (통합)
// /api/stores/clusters
// Query: level, bbox="xmin,ymin,xmax,ymax"
router.get('/stores/clusters', async (req, res) => {
  try {
    const level = parseInt(req.query.level, 10);
    const bbox = (req.query.bbox || '').split(',').map(Number);
    if (bbox.length !== 4 || bbox.some(n => Number.isNaN(n))) {
      return res.status(400).json({ error: 'invalid bbox' });
    }
    const [xmin, ymin, xmax, ymax] = bbox;

    // 레벨→모드/셀크기 결정
    let mode = 'individual';
    let grid = null;
    if (level <= 5) {
      mode = 'individual';
    } else if (level <= 7) {
      mode = 'cluster'; grid = 300;       // m
    } else if (level <= 10) {
      mode = 'cluster'; grid = 2000;      // m
    } else {
      mode = 'cluster'; grid = 10000;     // m
    }

    if (mode === 'individual') {
      const sql = `
        WITH viewport AS (
          SELECT ST_MakeEnvelope($1,$2,$3,$4,4326) AS box
        )
        SELECT
          'individual' AS kind,
          sa.id,
          sa.store_id,
          sa.road_address,
          ST_X(sa.geom) AS lon,
          ST_Y(sa.geom) AS lat
        FROM store_addresses sa, viewport v
        WHERE sa.geom && v.box
          AND ST_Intersects(sa.geom, v.box)
        LIMIT 5000;
      `;
      const { rows } = await pool.query(sql, [xmin, ymin, xmax, ymax]);
      return res.json({ type: 'individual', features: rows });
    } else {
      const sql = `
        WITH
        viewport AS (
          SELECT ST_MakeEnvelope($1,$2,$3,$4,4326) AS box4326
        ),
        v3857 AS (
          SELECT ST_Transform(box4326,3857) AS box3857 FROM viewport
        ),
        filtered AS (
          SELECT sa.*
          FROM store_addresses sa, viewport v
          WHERE sa.geom && v.box4326
            AND ST_Intersects(sa.geom, v.box4326)
        ),
        projected AS (
          SELECT id, store_id, road_address, ST_Transform(geom,3857) AS g3857
          FROM filtered
        ),
        gridded AS (
          SELECT
            ST_SnapToGrid(g3857, $5, $5) AS cell,
            COUNT(*) AS count,
            ST_Transform(ST_PointOnSurface(ST_Collect(g3857)),4326) AS rep_geom
          FROM projected, v3857
          WHERE g3857 && v3857.box3857
          GROUP BY ST_SnapToGrid(g3857, $5, $5)
        )
        SELECT
          'cluster' AS kind,
          count,
          ST_X(rep_geom) AS lon,
          ST_Y(rep_geom) AS lat
        FROM gridded;
      `;
      const { rows } = await pool.query(sql, [xmin, ymin, xmax, ymax, grid]);
      return res.json({ type: 'cluster', features: rows });
    }
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'internal' });
  }
});


응답 포맷 예시

// type: "individual"
{
  "type": "individual",
  "features": [
    { "kind":"individual", "id":123, "store_id":77, "road_address":"...", "lon":127.01, "lat":37.27 },
    ...
  ]
}

// type: "cluster"
{
  "type": "cluster",
  "features": [
    { "kind":"cluster", "count":12, "lon":127.02, "lat":37.30 },
    ...
  ]
}

7) 프론트 로직 간소화(핵심만)
async function refreshMarkers(level, bbox) {
  const qs = new URLSearchParams({ level: String(level), bbox: bbox.join(',') });
  const res = await fetch(`/api/stores/clusters?${qs}`);
  const data = await res.json();

  clearMarkersIfTypeChanged(data.type); // 타입 바뀌면 기존 마커 정리
  if (data.type === 'individual') {
    renderStoreMarkers(data.features);  // 개별 마커 그리기
  } else {
    renderClusterMarkers(data.features); // 집계 마커 그리기 (count 표시)
  }
}


기존 groupStoresByRegion, calculateAnchorPosition, 중복 마커 제거 같은 복잡 로직은 삭제.
줌 변경/이동 이벤트마다 한 번의 API 호출만.

8) 추가 최적화 팁

프리컴퓨트(선택): 광역 축소 레벨용 정적 그리드/행정단위 클러스터를 미리 물질화 뷰로 계산해두고 조회만 할 수도 있음.

Redis 캐시: cacheKey = level|bboxRounded 로 5~10초 캐시하면 응답 체감 크게 향상.

응답 축소: 개별 마커에서 지도에 안 쓰는 컬럼은 빼서 페이로드 최소화.

타일 API 전환(선택): 나중에 성능 한계 오면 z/x/y 벡터 타일 전략으로 전환 가능(MVT: ST_AsMVT).

9) 행정기관 좌표/읍면동 중심 우선순위는?

지금 구조에서는 DB가 대표점(rep_geom)을 산출하므로, 프론트에서 별도 우선순위 로직 불필요.

만약 특정 레벨에서 “무조건 행정센터로 표시”가 필요하면:

별도 테이블 admin_centers(emd_cd, geom)을 조인해서, 셀 내 대표점을 그 좌표로 대체하는 SQL 브랜치를 만들면 됨(선택).