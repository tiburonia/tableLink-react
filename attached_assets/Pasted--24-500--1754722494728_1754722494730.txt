증상: 지도 레벨을 올리면 집계마커와 개별 매장 마커가 동시에 표시됨.
특징: 기존 24개 더미데이터에서만 발생, 새로 추가한 500개에서는 정상.

🧠 유력 원인 (가설)
레거시 생성 경로 잔존

예전 코드에서 new kakao.maps.Marker(...).setMap(map)로 직접 만든 마커가 남아 있음.

현재 마커 레지스트리/토글 로직에서 그 마커들을 모름 → hide 대상에서 누락.

id 불일치/누락/중복

기존 24개 데이터의 id가 없거나 타입 혼합(숫자/문자열) 또는 중복.

Map 키 매칭 실패 → 일부 마커가 레지스트리에 저장 안 되고 hide에서 빠짐.

클러스터러/오버레이 잔여물

과거 MarkerClusterer 또는 CustomOverlay를 사용한 마커가 남아 있음.

현재는 Marker만 끄고, 클러스터/오버레이는 안 끔.

이중 전환 경로

idle, zoom_changed 등 둘 이상 이벤트에서 생성/표시가 발생.

전환 스위치가 2군데라 이전 모드가 꺼지기 전에 새 모드가 켜짐 → 동시표시.

다른 배열/레지스트리 사용

옛 배열(legacyMarkers)과 현재 배열(storeMarkers)이 따로 굴러감.

hide는 현재 배열만 돌고, 레거시 배열에 있는 24개는 그대로 노출.

좌표/타입 예외로 필터 누락

24개 좌표가 문자열/NaN 등으로 뷰포트 필터에서 빠지고,

별도 경로에서 show만 되고 hide는 안 됨(조건 미충족).

🧪 재현/확인 체크리스트
 코드 전체에서 new kakao.maps.Marker( 직접 생성 흔적 검색 → 전부 공용 팩토리로 통일되어 있는지.

 24개 데이터의 id 값 확인 → 존재/유일성/타입(문자열로 통일) 보장 여부.

 MarkerClusterer/커스텀 오버레이 사용 여부 확인 → 전환 시 clear()/setMap(null) 호출되는지.

 마커 생성/표시가 오직 한 함수(예: handleMapLevelChange)에서만 실행되는지.

 hide 루틴이 하나의 레지스트리(Set 또는 Map)에 등록된 모든 마커를 순회하는지.

 24개 좌표가 Number(lat/lng)로 강제 변환되는지(문자열로 남아있지 않은지).

🛠 수정 요청 (구체)
생성 경로 단일화

공용 팩토리 createStoreMarker(store, map)로만 마커 생성.

기존 직접 생성 마커가 있으면 팩토리 내부에서 레지스트리에 흡수.

하드 스위치(안전장치) 추가

모드 전환 시작 시 무조건 전부 OFF:

js
복사
편집
function hardHideAllMarkersAndOverlays(){
  MarkerRegistry.all.forEach(m => m.setMap(null));
  (window.RegionOverlays||[]).forEach(ov => ov.setMap(null));
  window.RegionOverlays = [];
  if (window.Clusterer) window.Clusterer.clear();
}
handleMapLevelChange 맨 앞에 hardHideAllMarkersAndOverlays() 호출.

ID 정규화

ensureStoreKey(store)로 id를 문자열로 통일, 누락 시 좌표 기반 대체키 생성.

js
복사
편집
function ensureStoreKey(store){
  return String(store.id ?? store.storeId ?? store._id ?? `${store.lat},${store.lng}`);
}
단일 전환 스위치화

마커/오버레이 show/hide/생성은 **오직 handleMapLevelChange**에서만 수행.

지도 이벤트도 한 군데(권장: idle)에서만 이 함수 호출.

뷰포트 필터 후 표시

map.getBounds()로 화면 내 매장만 대상으로 표시/집계.

좌표는 Number()로 강제 변환.

✅ 완료 기준
레벨 전환 시 집계마커와 개별마커가 동시에 표시되지 않음.

24개 구(레거시) 더미데이터도 새 500개와 동일하게 토글됨.

마커 깜빡임 최소(개별 마커는 최초 1회 생성, 이후 show/hide만).

전환 로직은 단 한 함수 진입점으로 관리되고, 전환 시작 시 전체 OFF 보장.