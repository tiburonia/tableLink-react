-- stores 와 FK로 연결된 모든 테이블(양방향) + stores 자체의 컬럼 스키마 출력
-- 필요하면 아래 WHERE c.relname = 'stores' 옆에 스키마 필터도 추가 가능
--   예: AND n.nspname = 'public'

WITH stores_tables AS (
  SELECT c.oid AS oid, n.nspname AS schema_name, c.relname AS table_name
  FROM pg_class c
  JOIN pg_namespace n ON n.oid = c.relnamespace
  WHERE c.relname = 'stores'
    AND c.relkind IN ('r','p','f')  -- 일반/파티션/외부 테이블
),
related AS (
  -- stores 를 참조하는 자식 테이블들
  SELECT con.conrelid AS oid
  FROM pg_constraint con
  JOIN stores_tables s ON con.confrelid = s.oid
  WHERE con.contype = 'f'
  UNION
  -- stores 가 참조하는 부모 테이블들
  SELECT con.confrelid AS oid
  FROM pg_constraint con
  JOIN stores_tables s ON con.conrelid = s.oid
  WHERE con.contype = 'f'
),
all_tables AS (
  SELECT * FROM stores_tables
  UNION
  SELECT c.oid, n.nspname, c.relname
  FROM pg_class c
  JOIN pg_namespace n ON n.oid = c.relnamespace
  WHERE c.oid IN (SELECT oid FROM related)
),
pk_cols AS (
  SELECT i.indrelid AS oid, a.attname AS column_name
  FROM pg_index i
  JOIN pg_attribute a
    ON a.attrelid = i.indrelid
   AND a.attnum = ANY(i.indkey)
   AND a.attnum > 0
  WHERE i.indisprimary
),
fk_cols AS (
  -- FK 컬럼별로 참조 대상까지 펼쳐서 매핑
  SELECT
    con.conrelid AS oid,
    a.attname AS column_name,
    n2.nspname AS references_schema,
    c2.relname AS references_table,
    a2.attname AS references_column,
    con.conname AS constraint_name
  FROM pg_constraint con
  JOIN generate_subscripts(con.conkey, 1) AS k(i) ON TRUE
  JOIN pg_attribute a
    ON a.attrelid = con.conrelid
   AND a.attnum   = con.conkey[k.i]
  JOIN pg_class c2 ON c2.oid = con.confrelid
  JOIN pg_namespace n2 ON n2.oid = c2.relnamespace
  JOIN pg_attribute a2
    ON a2.attrelid = con.confrelid
   AND a2.attnum   = con.confkey[k.i]
  WHERE con.contype = 'f'
),
cols AS (
  SELECT
    at.schema_name,
    at.table_name,
    c.ordinal_position,
    c.column_name,
    c.data_type,
    c.character_maximum_length,
    c.numeric_precision,
    c.numeric_scale,
    c.is_nullable,
    c.column_default,
    (pk.column_name IS NOT NULL) AS is_primary_key,
    (fk.column_name IS NOT NULL) AS is_foreign_key,
    fk.references_schema,
    fk.references_table,
    fk.references_column,
    fk.constraint_name
  FROM all_tables at
  JOIN information_schema.columns c
    ON c.table_schema = at.schema_name
   AND c.table_name   = at.table_name
  LEFT JOIN pk_cols pk
    ON pk.oid = at.oid AND pk.column_name = c.column_name
  LEFT JOIN fk_cols fk
    ON fk.oid = at.oid AND fk.column_name = c.column_name
)
SELECT
  schema_name  AS table_schema,
  table_name,
  ordinal_position,
  column_name,
  data_type,
  COALESCE(character_maximum_length::text, '') AS char_max_length,
  COALESCE(numeric_precision::text, '')        AS numeric_precision,
  COALESCE(numeric_scale::text, '')            AS numeric_scale,
  is_nullable,
  column_default,
  is_primary_key,
  is_foreign_key,
  references_schema,
  references_table,
  references_column,
  constraint_name
FROM cols
ORDER BY table_schema, table_name, ordinal_position;
